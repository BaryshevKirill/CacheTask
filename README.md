# CacheTask
Кеширование в памяти (LRU, LFU)

Настроечные параметры для кеша находятся в файле src/main/CacheConfig.properties.
cache.cacheSize - размерность кеша
cache.strategy - стратегия удаления (LRU/LFU)

Формирование спринг контекста проивходит с п-ю applicationContext.xml.
В зависимости от входных парметров в src/main/CacheConfig.properties формируется бин используя CacheFactory.java.
В конструктор CacheFactory.java передаются 2 параметра тип алгоритма (LRU/LFU) и размерность кеша.
В зависимости от параметра "Тип алгоритма" будет формироваться одна из реализаций интерфейса Cache.java.

Для тестов.
Формирование происходит аналогично.
Созданы отдельные файлы для настройки тестового контекста (applicationContext-test.xml) и файл конфигов (Config.properties).

-------------------LRU---------------------
Как реализован кеш  с алгоритмом удаления LRU (вытесняется буфер, неиспользованный дольше всех):
При добавлении элемента в кеш происходит проверка на заполненность кеша, если место в кеше есть, то элемент добавляется в HashMap (mapWithValue), а так же в конец LinkedList (listOfKeys).
Если места в кеше нет, то вызывается метод removeValue, который удаляет один эелемент. Псле этого происходит добавление нового элемента в кеш.
АЛГОРИТМ УДАЛЕНИЯ:
- Удаляем из mapWithValue элемент с ключом полученного из listOfKeys по индексу 0.
- Удаляем из listOfKeys элемент с индексом 0.
P.S. Т.к. при добавлении в LinkedList элемент добавляется в конец. А так же LinkedList выбран в связи с тем, что добавление  в конец и удаление из начала выполняется за O(1)

При получении элемента из кеша происходит проверка наличия данного ключа в кеше, если он то:
1) Мы удаляем из listOfKeys элемент со значением ключа
2) Мы добавляем в listOfKeys элемент со значением ключа (по итогу добавленный элемент оказывается самым последним, т.е. самы последний использованный)
3) Возвращаем значение из кеша по ключу.

Информация по сложности алгоритмов:
Добавление в кеш если он не заполнен полностью: O(1) + O(log n) (O(1) для LinkedList)
Добавление в кеш если он заполнен полностью: O(1) + O(log n) + O(1) + O(log n)  (Вставка и удаление)
Удаление в среденм O(1) + O(log n) (O(1) для LinkedList)
Получение элемента в среднем O(log n)

-------------------LFU---------------------
Как реализован кеш  с алгоритмом удаления LFU (вытесняется буфер, использованный реже всех;):
При добавлении элемента в кеш происходит проверка на заполненность кеша, если место в кеше есть, то элемент добавляется в HashMap (mapWithValue),
а так же в HashMap (mapWithCount) в которой значением является 1.
Если места в кеше нет, то вызывается метод removeValue, который удаляет один эелемент. Псле этого происходит добавление нового элемента в кеш.
АЛГОРИТМ УДАЛЕНИЯ:
- Ищем в mapWithValue ключ у которого минимальное значение ключа
- По найденному ключу удаляем элемент из mapWithValue и из mapWithValue
- Удаляем из mapWithValue элемент с ключом полученного из listOfKeys по индексу 0.

Информация по сложности алгоритмов:
Добавление в кеш если он не заполнен полностью: O(log n) + O(log n)
Добавление в кеш если он заполнен полностью: O(n) + O(log n) + O(log n) + O(log n) + O(log n)  (Вставка и удаление)
Удаление в среденм O(n) + O(log n) + O(log n)
Получение элемента в среднем O(log n)
