# CacheTask
Кеширование в памяти (LRU, LFU)

## Настроечные параметры для кеша находятся в файле src/main/CacheConfig.properties.
cache.cacheSize - размерность кеша
cache.strategy - стратегия удаления (LRU/LFU)

### Формирование спринг контекста проивходит с п-ю applicationContext.xml.
В зависимости от входных парметров в src/main/CacheConfig.properties формируется бин используя CacheFactory.java.
В конструктор CacheFactory.java передаются 2 параметра тип алгоритма (LRU/LFU) и размерность кеша.
В зависимости от параметра "Тип алгоритма" будет формироваться одна из реализаций интерфейса Cache.java.

## Для тестов.
Формирование происходит аналогично.
Созданы отдельные файлы для настройки тестового контекста (applicationContext-test.xml) и файл конфигов (Config.properties).

## LRU
Как реализован кеш  с алгоритмом удаления LRU (вытесняется буфер, неиспользованный дольше всех):
При добавлении элемента в кеш происходит проверка на заполненность кеша, если место в кеше есть, то элемент добавляется в LinkedHashMap (mapWithValue).
Если места в кеше нет, то вызывается метод removeValue, который удаляет один эелемент. Псле этого происходит добавление нового элемента в кеш.
### Алгоритм удаления:
- Удаляем из mapWithValue первый элемент (т.е. самый старый).

При получении элемента из кеша происходит проверка наличия данного ключа в кеше, если он присутствует то:
- Берем из mapWithValue занчение. (т.к. параметр accesOrder = true , то при получении элемента он помещаетя в конец мапы)

Информация по сложности алгоритмов:
Добавление в кеш если он не заполнен полностью: O(1)
Добавление в кеш если он заполнен полностью: O(1) + O(1) = O(1)  (Вставка и удаление)
Удаление  O(1)
Получение элемента O(1)

## LFU
Как реализован кеш  с алгоритмом удаления LFU (вытесняется буфер, использованный реже всех;):
При добавлении элемента в кеш происходит проверка на заполненность кеша, если место в кеше есть, то элемент добавляется в HashMap (mapWithValue),
а так же в HashMap (mapWithCount) в которой значением является 1.
Если места в кеше нет, то вызывается метод removeValue, который удаляет один эелемент. Псле этого происходит добавление нового элемента в кеш.
### Алгоритм удаления:
- Ищем в mapWithValue ключ у которого минимальное значение ключа
- По найденному ключу удаляем элемент из mapWithValue и из mapWithValue
- Удаляем из mapWithValue элемент с ключом полученного из listOfKeys по индексу 0.

Информация по сложности алгоритмов:
Добавление в кеш если он не заполнен полностью: O(1) + O(1) = O(1)
Удаление O(n) + O(1) + O(1) = O(n) (найти минимальный + удалить из 2ух мап)
Получение элемента O(1)

## P.S. Сложности указаны в идеальных условиях, если хеши ключей всегда разные
